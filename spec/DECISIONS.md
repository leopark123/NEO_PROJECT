# 📋 架构决策记录（Architecture Decision Records）

> **版本**: v1.6  
> **最后更新**: 2026-01-25  
> **作用**: 记录关键技术决策及其理由  
> **v1.6变更**: 新增 ADR-012(时间戳主机打点)、ADR-013(NIRS阈值不推断)、ADR-014(300GiB滚动留存)  
> **v1.5变更**: 新增 ADR-011 视频同步策略（USB摄像头+主机时间戳已确认）  
> **v1.4变更**: ADR-003标注被ADR-009替代、ADR-010补充EEG时间戳策略和视频待确认清单

---

## ADR-001: 统一时间轴设计

### 状态
✅ 已采纳

### 背景
系统需要同步 EEG（160Hz）、aEEG（1Hz）、NIRS（1-4Hz）、Video（30fps）等多种不同采样率的数据流，同时支持 72 小时长程监护。

### 决策
采用 **Monotonic Time + UTC Offset** 方案：

```csharp
public readonly struct GlobalTime {
    public long MonotonicMicroseconds { get; }  // int64 微秒，单调递增
    public long UtcOffsetMicroseconds { get; }  // 与UTC的偏移
    
    public DateTime ToUtc() => 
        DateTime.UnixEpoch.AddTicks(
            (MonotonicMicroseconds + UtcOffsetMicroseconds) * 10);
}
```

### 关键设计点
- **精度**: 微秒(μs)，支持 Video 帧同步
- **范围**: int64 可表示约 292,000 年
- **单一 Playhead**: 全系统共用一个时间游标
- **纪元**: 监护开始时刻 = 0

### 理由
- 微秒精度支持未来更高采样率和精确视频同步
- Monotonic 保证不受系统时间调整影响
- UTC Offset 支持绝对时间显示和跨时区
- int64 避免溢出风险

### 后果
- ✅ 多模态数据精确同步
- ✅ 回放时时间轴统一
- ⚠️ 需要所有模块统一使用此时间基准

---

## ADR-002: 渲染引擎选择 Vortice

### 状态
✅ 已采纳

### 背景
SharpDX 已停止维护，需要选择替代方案。

### 候选方案
| 方案 | 维护状态 | API 相似度 | 性能 |
|------|----------|-----------|------|
| Vortice | 活跃 | 高 | 优秀 |
| Silk.NET | 活跃 | 中 | 优秀 |
| 原生 D3D11 | N/A | N/A | 最优 |

### 决策
选择 **Vortice**

### 理由
- 活跃维护，持续更新
- API 与 SharpDX 高度相似，迁移成本低
- 性能优秀，开销极小
- 社区支持良好

### 后果
- ✅ 代码可维护性好
- ✅ 未来升级有保障
- ⚠️ 需要学习 Vortice 特有 API

---

## ADR-003: 存储架构分层（已被 ADR-009 替代）

### 状态
⚠️ **已被替代** — 请参见 ADR-009

### 原决策（历史记录）
SQLite 仅用于索引元数据，波形数据使用 EDF+ 或自定义二进制分段文件。

### 替代原因
ADR-009 统一采用 "SQLite + Chunk（多文件分段）" 方案：
- 波形数据也存入 SQLite（按小时分文件）
- 简化架构，减少文件格式混杂
- 统一查询接口

### 现行决策
**请参见 ADR-009: 存储后端选型（SQLite + Chunk）**

---

## ADR-004: Zoom Out 使用 Min/Max 包络

### 状态
✅ 已采纳

### 背景
72 小时数据在屏幕上显示时需要降采样，但不能丢失尖峰。

### 决策
使用 **LOD (Level of Detail) 金字塔**：

```
Level 0: 原始数据 160Hz
Level 1: 2:1 降采样，每2样本保留 (min, max)
Level 2: 4:1 降采样，每4样本保留 (min, max)
...
Level 25: 约 1 sample/小时
```

### 参数（基于160Hz）
```yaml
base_rate: 160 Hz
max_duration: 72 hours
max_samples: 41,472,000
max_levels: 26
```

### 理由
- 平均值会"抹平"尖峰
- 跳点采样会完全丢失尖峰
- Min/Max 包络保证尖峰可见
- 金字塔结构支持快速多级缩放

### 后果
- ✅ 尖峰始终可见
- ✅ 缩放流畅
- ⚠️ 存储空间增加约 2x（每层额外存 min/max）

---

## ADR-005: Gap 不插值策略

### 状态
✅ 已采纳

### 背景
数据缺失（gap）时如何处理显示？

### 决策
```yaml
gap_threshold: 4 samples      # 160Hz × 25ms = 4
  
policy:
  ≤4 samples: 可选线性插值，但必须标记
  >4 samples: 强制断裂 + 灰色遮罩，禁止插值
```

### 视觉表现
```
正常数据 ~~~~~~~~~~~|      GAP      |~~~~~~~~~~~~ 正常数据
                   断裂    灰色遮罩    断裂
```

### 理由
- 长 gap 插值等于"伪造数据"
- 临床医生必须知道数据缺失
- 短 gap 插值可接受（<25ms 对临床无影响）

### 后果
- ✅ 数据完整性透明
- ✅ 避免误诊风险
- ⚠️ 视觉上不"完美"

---

## ADR-006: 滤波器使用 double 精度

### 状态
✅ 已采纳

### 背景
IIR 滤波器的数值稳定性问题。

### 问题演示
```
0.3Hz 高通 @ 160Hz 的极点位置:
  |z| = 0.9988...
  
float 精度: 约 7 位有效数字
  z_float = 0.998800 (精度丢失)
  
double 精度: 约 15 位有效数字
  z_double = 0.99882575...（精确）
```

### 决策
```csharp
// 必须使用 double
double[] b;  // 分子系数
double[] a;  // 分母系数
double[] z;  // 状态变量
```

### 理由
- 低频滤波器极点接近单位圆
- float 精度不足导致漂移/振荡
- double 开销可忽略（CPU 运算）

### 后果
- ✅ 数值稳定
- ✅ 长时间运行无漂移
- ⚠️ 内存占用略增（可忽略）

---

## ADR-007: 无锁数据交换设计

### 状态
✅ 已采纳

### 背景
DSP 线程和渲染线程需要高效交换数据，不能互相阻塞。

### 决策
采用 **Owned Double Buffer** 模式：

```csharp
class OwnedDoubleBuffer<T> {
    private T[] _bufferA, _bufferB;
    private volatile int _publishedIndex;
    
    // 生产者线程
    public void Produce(Action<T[]> writeAction) {
        var writeBuffer = (_publishedIndex == 0) ? _bufferB : _bufferA;
        writeAction(writeBuffer);
        Interlocked.Exchange(ref _publishedIndex, 
            (_publishedIndex == 0) ? 1 : 0);
    }
    
    // 消费者线程
    public T[] GetLatest() {
        return (_publishedIndex == 0) ? _bufferA : _bufferB;
    }
}
```

### 理由
- 无锁：生产者和消费者不互相阻塞
- 无拷贝：消费者直接读取发布的缓冲
- 简单：只需一个 volatile int

### 后果
- ✅ 高性能
- ✅ 无死锁风险
- ⚠️ 消费者可能读到"上一帧"数据（可接受）

---

## ADR-008: 三层渲染架构

### 状态
✅ 已采纳

### 背景
如何高效渲染多通道波形 + 网格 + 交互元素？

### 决策
三层分离：

```
┌─────────────────────────────────────────┐
│ Layer 3: Overlay (每帧重绘)             │
│ - 光标、标注、弹出菜单                   │
├─────────────────────────────────────────┤
│ Layer 2: Waveform (每帧重绘)            │
│ - 4通道 EEG 波形                        │
│ - 4通道 aEEG 趋势（对数Y轴）            │
│ - 6通道 NIRS 趋势                       │
├─────────────────────────────────────────┤
│ Layer 1: Grid (缓存到纹理)              │
│ - 背景、网格、刻度、标签                 │
│ - 仅 DPI/窗口变化时重绘                 │
└─────────────────────────────────────────┘
```

### 理由
- Grid 变化少，缓存节省 GPU 资源
- Waveform 必须实时更新
- Overlay 独立于数据，便于交互

### 后果
- ✅ 高帧率（≥120 FPS）
- ✅ 清晰的代码分层
- ⚠️ DPI 切换时需要重建 Grid 纹理

---

## ADR-009: 存储后端选型（SQLite + Chunk）

### 状态
✅ 已采纳

### 背景
系统需要存储 72 小时连续监护数据，包括：
- EEG: 160Hz × 4通道 × 72h = ~330MB
- NIRS: 4Hz × 6通道 × 72h = ~25MB  
- aEEG: 1Hz × 4通道 × 72h = ~8MB
- Video: ~5GB（独立存储）
- 审计日志: 持续增长

需要支持：实时写入、历史回放查询、离线部署、医疗合规审计。

### 候选方案

| 方案 | 优点 | 缺点 |
|------|------|------|
| **SQLite + Chunk** | 零部署、嵌入式、单文件备份、ACID | 单写限制、不支持网络共享 |
| PostgreSQL | 高并发、网络访问、成熟生态 | 需要安装部署、运维成本 |
| TimescaleDB | 时序优化、自动分区、压缩 | 依赖PostgreSQL、资源消耗大 |
| InfluxDB | 时序专用、高写入吞吐 | 查询能力有限、学习曲线 |
| 纯文件 (EDF+) | 医疗标准、简单 | 无索引、查询慢、无事务 |

### 决策
选择 **SQLite + Chunk（多文件分段）** 方案

### 关键配置
```yaml
sqlite:
  journal_mode: WAL
  synchronous: NORMAL
  busy_timeout: 5000
  
chunk:
  method: multi_file
  granularity: 1 hour
  pattern: "eeg_{patient_id}_{YYYYMMDD_HH}.db"
```

### 理由
1. **零部署依赖**：医疗设备离线运行，无需数据库服务
2. **单文件备份**：便于数据迁移和归档
3. **ACID 保证**：事务保证数据完整性
4. **成熟稳定**：SQLite 是世界上部署最广泛的数据库
5. **Chunk 分段**：避免单文件过大，便于滚动清理
6. **WAL 模式**：读写分离，查询不阻塞写入

### 升级触发条件
当满足以下任一条件时，必须评估升级到 PostgreSQL/TimescaleDB：

| 触发条件 | 说明 |
|----------|------|
| 多客户端并发写入 | 需要 >1 个写入源 |
| 网络共享需求 | 需要中心化数据服务 |
| 长期数据存储 | 留存从 72h 提升到数月/数年 |
| 复杂分析需求 | 跨患者/跨设备聚合分析 |
| 团队运维成熟 | 有专业 DBA 支持 |

### 后果
- ✅ 开发部署简单
- ✅ 离线运行友好
- ✅ 数据完整性有保证
- ⚠️ 单写线程限制（当前场景可接受）
- ⚠️ 不支持网络并发访问（当前场景不需要）

---

## ADR-010: 时间同步策略（临时方案）

### 状态
⚠️ **临时采纳**（待设备信息确认后修订）

### 背景
系统需要同步 EEG / NIRS / Video 三个数据源的时间轴。当前：
- 视频设备类型未确定（UVC/RTSP/SDK）
- 视频帧时间戳来源未确定
- EEG 设备**不提供硬件时间戳**（仅有 GS counter 用于 aEEG）
- 三者是否共用时钟未确定

### 临时决策
采用 **"主机时间对齐"** 方案：

```
所有数据源在主机接收/采集时，使用主机单调时钟打时间戳：
- EEG: 数据包到达时 → HostClock.NowMicroseconds()
- NIRS: 数据包到达时 → HostClock.NowMicroseconds()
- Video: 帧采集时 → HostClock.NowMicroseconds()
```

### EEG 时间戳具体策略

```yaml
eeg_timestamp:
  source: Host (主机打点)
  method: 
    - 每个数据包到达时立即打时间戳
    - 包内多样本按采样率推算：sample[i].ts = packet.ts + i * 6250μs
  sample_interval: 6250 μs  # 1/160Hz
  packet_sequence: 
    - 用于检测丢包（序号不连续 = Gap）
    - 不作为时间源
  precision: ±1-10 ms (受串口缓冲和调度影响)
```

### Monotonic → Wall Clock 映射

```csharp
public class TimeMapping
{
    // 会话开始时记录
    private readonly DateTime _wallClockStart;
    private readonly long _monotonicStartUs;
    
    public TimeMapping()
    {
        _wallClockStart = DateTime.UtcNow;
        _monotonicStartUs = HostClock.NowMicroseconds();
    }
    
    // 转换公式
    public DateTime ToWallClock(long monotonicUs)
    {
        long elapsedUs = monotonicUs - _monotonicStartUs;
        return _wallClockStart.AddTicks(elapsedUs * 10); // 1μs = 10 ticks
    }
}

// 漂移处理策略：
// - 短期监护 (<72h)：忽略漂移，误差可接受
// - 长期监护 (>72h)：需定期与 NTP 校准（未来实现）
```

### 时钟域定义
```csharp
public enum ClockDomain
{
    Device,   // 设备硬件时钟（最高精度）- 当前不可用
    Host,     // 主机单调时钟（当前使用）
    Unknown   // 时钟来源不可靠
}
```

### 预估精度
| 因素 | 误差 |
|------|------|
| 主机时钟 | < 1 μs |
| 串口接收延迟 | 1-10 ms |
| 调度抖动 | 0-5 ms |
| **EEG 总体** | **±10-15 ms** |
| **Video 总体** | **±20-50 ms**（估计，待确认）|

### 待确认事项（阻塞 Sprint 3 视频同步）

```
视频信息待确认清单：
□ 视频来源类型：UVC / RTSP / SDK / 其他
□ 视频编码格式：H.264 / H.265 / MJPEG / 其他
□ 是否有硬件 PTS：有 / 无 / 不确定
□ 获取帧的 API：MediaFoundation / FFmpeg / GStreamer / 厂商SDK
□ 目标同步精度：±50ms / ±100ms / 其他
□ 是否需要录制存储：是 / 否
```

### 升级触发条件
当满足以下任一条件时，必须评估升级：
- [ ] 临床验证发现同步精度不足
- [ ] 获得设备硬件时间戳能力
- [ ] 需要跨设备精确对齐

### 升级路径
1. 确认设备时间戳能力
2. 实现时钟域转换
3. 可选：实现 drift 校正算法

### 后果
- ✅ 可立即开发，不阻塞 Sprint 1-2
- ✅ 架构预留升级接口
- ⚠️ EEG 同步精度 ±15ms（临床可接受）
- ⚠️ Video 同步精度待验证（Sprint 3）

### 相关文档
- 详细方案见: `spec/TIME_SYNC.md`

---

## ADR-011: 视频同步策略（已确认）

### 状态
✅ **已采纳**（设备信息已确认）

### 背景
需要确定视频与 EEG 的同步方案。经指挥官确认，视频设备为：
- 通用 USB 摄像头（UVC 协议）
- 无专用 SDK
- 无硬件同步能力

### 决策
采用 **"主机时间戳 + 软件对齐"** 方案：

```
┌─────────────────────────────────────────────────────────────────┐
│                    视频同步策略                                  │
├─────────────────────────────────────────────────────────────────┤
│  时间戳来源  │  主机 Monotonic Clock（与 EEG 共享）             │
│  打戳时机    │  帧采集完成时立即打戳                            │
│  时钟域      │  ClockDomain.Host                               │
│  同步精度    │  ±50-100ms（毫秒级）                            │
│  对齐方式    │  软件对齐（非硬件触发）                          │
└─────────────────────────────────────────────────────────────────┘
```

### 实现要点

```csharp
public class UvcVideoAdapter : IVideoSource
{
    public void OnFrameCaptured(byte[] data)
    {
        // 与 EEG 使用相同的时钟源
        long timestampUs = HostClock.NowMicroseconds();
        
        var frame = new VideoFrame
        {
            TimestampUs = timestampUs,
            ClockDomain = ClockDomain.Host,
            Data = data
        };
        
        FrameReceived?.Invoke(this, frame);
    }
}
```

### 理由
1. **设备限制**：USB 摄像头无硬件同步能力，无法提供可靠的设备时间戳
2. **简化实现**：无需处理设备时钟与主机时钟的转换
3. **精度足够**：毫秒级精度满足"观察患者行为与脑电对应"的临床需求
4. **一致性**：与 EEG 使用相同时钟源，避免时钟域转换误差

### 精度分析

| 误差来源 | 估计值 | 说明 |
|----------|--------|------|
| USB 传输延迟 | 10-30ms | USB 2.0 bulk 传输 |
| 帧解码延迟 | 5-20ms | 取决于分辨率和编码 |
| 调度抖动 | 5-30ms | 取决于系统负载 |
| **总计** | **±50-100ms** | 毫秒级 |

### 后果
- ✅ 实现简单，无需处理时钟转换
- ✅ 与 EEG 时间轴天然对齐
- ✅ 满足临床观察需求
- ⚠️ 精度不足以支持精确的事件标记（如需要可后续升级）

### 未来升级路径
若需更高精度，可考虑：
1. 更换支持 PTS 的专业摄像头
2. 使用硬件触发（GPIO 同步）
3. 引入 NTP/PTP 时钟同步

### 相关文档
- `spec/CONSENSUS_BASELINE.md` §6.7
- `spec/ARCHITECTURE.md` §7.0
- `spec/TIME_SYNC.md`

---

## ADR-012: 时间戳统一主机打点

### 状态
✅ **已采纳**

### 背景
v1.2 补充冻结需要明确所有数据源的时间戳策略，确保 EEG/NIRS/Video 三种数据源时间戳一致性。

### 决策
**所有数据源（EEG/NIRS/Video）统一采用主机打点时间戳**：

| 项目 | 规格 |
|------|------|
| 打点方式 | 数据到达主机时立即打戳 |
| 存储精度 | int64 微秒 (μs) |
| 对齐目标 | 毫秒级 (ms) |
| 时钟源 | 主机 Monotonic Clock |

### 理由
1. **无硬件同步能力**：设备均不提供可靠的硬件时间戳
2. **主机时钟是唯一可信时间源**：EEG/NIRS/Video 共用同一时钟
3. **统一策略简化实现**：避免复杂的时钟域转换

### 后果
- ✅ 所有数据源时间戳对齐
- ✅ 实现简单，无需时钟转换
- ⚠️ 禁止依赖设备内部时钟
- ⚠️ 禁止使用设备 PTS

---

## ADR-013: NIRS 阈值/单位不推断

### 状态
✅ **已采纳**

### 背景
NIRS 显示的阈值（危险区、警告区、正常区）涉及医学判断，需明确责任边界，防止软件层越权解释医学参数。

### 决策
**NIRS 阈值/单位禁止软件推断**，完全来源于设备规格，通过配置加载：

| 项目 | 规格 |
|------|------|
| 阈值来源 | 设备规格 / 配置文件 |
| 当前状态 | TBD（待设备规格确认） |
| 配置入口 | 预留阈值配置界面 |

### 理由
1. **医学责任边界**：软件不承担医学判断责任
2. **设备依赖**：不同设备可能有不同阈值
3. **临床风险**：错误阈值可能导致误诊

### 后果
- ✅ 明确责任边界
- ✅ 支持多设备适配
- ⚠️ 禁止自适应修正
- ⚠️ 禁止智能判断
- ⚠️ 禁止推断重标定

---

## ADR-014: 300GiB 滚动留存

### 状态
✅ **已采纳**

### 背景
系统需要长期运行，存储空间有限，需要自动管理策略。床旁监护设备通常只监护单一患者，需要保证当前监护不中断。

### 决策
**存储上限 300GiB，超限时滚动删除最旧患者会话，不中断当前监护**：

| 策略项 | 规格 |
|--------|------|
| 存储上限 | 300 GiB（可配置） |
| 删除粒度 | 按患者会话整体删除 |
| 删除保护 | 当前活跃监护不可删除 |
| 监护连续性 | 清理过程不中断当前监护 |
| 清理触发 | 存储使用率 > 90% |

### 理由
1. **床旁设备场景**：单一患者监护，无需复杂多患者管理
2. **数据完整性**：按会话删除避免数据碎片化
3. **临床安全**：保护当前监护避免数据丢失

### 后果
- ✅ 自动管理存储空间
- ✅ 保证当前监护连续性
- ✅ 数据按会话整体管理
- ⚠️ StorageManager 需实现滚动清理逻辑
- ⚠️ 删除操作需记录审计日志

---

## ADR-015: S1-02 RS232 Source 范围裁决与 NIRS 拆分

### 状态
✅ **已采纳（冻结）**

### 背景
在执行 **S1-02（RS232 Source）** 过程中，完成了 EEG + aEEG（GS）相关的串口解析、异常上报与测试覆盖，并通过二次审查。

审查同时发现：
1. **ICD 协议字段表以二进制 `.doc` 形式存在，无法被直接引用与审计**
2. **NIRS 的 RS232 协议字段表在规格文档中未定义**
3. 项目铁律要求：**无证据字段不得推断实现**

上述问题并非工程缺陷，而是**规格证据缺失**，若继续实现将违反"可审计、不可猜测"原则。

### 决策

#### 1. S1-02 范围裁决（冻结）

**S1-02 仅验收 EEG + aEEG（GS）RS232 实现**，包含：
- AA55 帧头 + 36 bytes 数据 + 校验
- EEG 160 Hz 数据流（4 通道：CH1-3 物理 + CH4 计算）
- GS 直方图（counter 255=无效 / 229=周期结束）
- 异常上报（SerialErrorOccurred）
- 测试覆盖关键边界条件

**不包含 NIRS 协议解析**。该范围视为 **S1-02a（EEG-only）**。

#### 2. NIRS 协议实现拆分为独立任务（Blocked）

| 项目 | 规格 |
|------|------|
| 新任务 | S3-00 — NIRS RS232 Protocol Spec & Parser |
| 当前状态 | 🚫 **Blocked** |
| 阻塞原因 | 缺失协议证据 |

缺失的最小必要证据：
1. 帧头定义
2. 每帧长度（bytes）
3. 字节序
4. 校验算法（CRC/Checksum）
5. 字段映射（通道/状态/单位）

在上述证据未以**可引用文本（docx/pdf/md）**形式提供前：
- ❌ 不得实现
- ❌ 不得推断
- ❌ 不得写占位解析逻辑

### 理由
1. **可审计原则**：实现必须有证据支持
2. **临床安全**：协议错误可能导致数据误读
3. **进度优先级**：Sprint 1 不因 NIRS 阻塞

### 后果
- ✅ Sprint 1 正常完成
- ✅ EEG/aEEG 链路保持完全可审计
- ✅ 防止"猜协议"造成技术债与医疗风险
- ⚠️ NIRS 功能延后至协议明确后
- ⚠️ 需要额外一次协议补充与审查流程

### 更新 (2026-02-06): S3-00 已解冻

**状态变更**: 🚫 Blocked → ✅ 已解冻

**解冻依据**: `evidence/sources/icd/ICD_NIRS_RS232_Protocol_Fields.md` 完整提供所有必需证据

**证据验收结果**:
1. ✅ 帧头定义 - ASCII "Ch1" 标记，CR/LF 终止符
2. ✅ 每帧长度 - 250-350 bytes 可变长，含完整字段图
3. ✅ 字节序 - ASCII 协议，CRC 大端序明确说明
4. ✅ 校验算法 - CRC-16 CCITT (XMODEM)，含 C/Python 参考代码 + 测试向量 (0x31C3)
5. ✅ 字段映射 - 6 通道完整映射 (Ch1-4 物理 + Ch5-6 虚拟) + rSO₂/HbI/AUC 参数

**验收标准**: 全部 5 项通过
- ✅ 可引用 (Markdown 文档，v1.0)
- ✅ 字节级精度 (所有字段偏移/长度/类型/分隔符明确)
- ✅ 可独立验证 (含 CRC 测试向量、参考实现、解析逻辑)
- ✅ 含校验算法 (CRC-16 完整实现)
- ✅ 覆盖 6 通道 (Ch1-4 显式 + Ch5-6 虚拟通道缓解方案)

**下一步**: S3-00 进入实现阶段，基于 ICD §9 参考实现开发 NIRS 解析器

### 裁决原则引用
- **不可推断未知字段**
- **实现必须有证据支持**
- **临床与协议安全优先于进度**

---

## 变更记录

| 版本 | 日期 | 变更 |
|------|------|------|
| v1.0 | 2025-01-21 | 初始版本（8条ADR） |
| v1.1 | 2025-01-21 | ADR-001: 毫秒→微秒；ADR-004/005: 基于160Hz重算参数；ADR-008: 更新通道数 |
| v1.2 | 2025-01-21 | 新增 ADR-009: 存储后端选型（SQLite + Chunk） |
| v1.3 | 2025-01-21 | 新增 ADR-010: 时间同步策略（临时方案） |
| v1.4 | 2025-01-21 | ADR-003 标注被 ADR-009 替代；ADR-010 补充 EEG 无硬件时间戳事实、视频待确认清单 |
| v1.5 | 2025-01-21 | 新增 ADR-011: 视频同步策略（USB摄像头+主机时间戳已确认） |
| v1.6 | 2026-01-25 | 新增 ADR-012(时间戳主机打点)、ADR-013(NIRS阈值不推断)、ADR-014(300GiB滚动留存) |
| v1.7 | 2026-01-28 | 新增 ADR-015(S1-02范围裁决：EEG-only，NIRS拆分为Blocked任务) |
